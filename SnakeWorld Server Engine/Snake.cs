using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Threading;
using System.Linq;
using System.Security.Cryptography;

using System.IO;
using System.Net;
using System.Net.Sockets;

namespace SnakeWorld_Server
{
    public class Snake : SceneTreeItem<Snake>, Identificable
    {
        #region variables
        /// <summary>
        /// Used connection with the client.
        /// </summary>
        public readonly BinaryReader br;
        public readonly BufferedBinaryWriter bw;
        public readonly NetworkStream networkStream;

        /// <summary>
        /// the lock
        /// </summary>
        private ReaderWriterLock rwLock = new ReaderWriterLock();
        
        /// <summary>
        /// Unique identifier of the snake.
        /// Choosen by the server.
        /// </summary>
        private readonly UInt32 snakeId;

        /// <summary>
        /// The snake state.
        /// [segments...head]
        /// Kept up-to-date by the client.
        /// </summary>
        private SnakeSegment segments,      // list of segments (from the after-tail to the after-head)
                             lastSegment;   // the last segment in the segments (the first segment after the head)
        private double segmentsLength;      // sum of the distances between segments
        private Position head;              // head position
        private double snakeHeadDirection;  // in radians

        /// <summary>
        /// Current snake length.
        /// In meters.
        /// </summary>
        private double snakeLength = 33.0;         // current snake length in meters.

        /// <summary>
        /// Current snake speed.
        /// In meters/sec.
        /// </summary>
        private double snakeSpeed = 16.0;         // current snake length in meters.

        /// <summary>
        /// The snake specification
        /// </summary>
        private string   _Name,
                        _Description,
                        _TextureFile,
                        _BodyType;

        public UInt32 LanguageCode = 0;

        /// <summary>
        /// Snake bound rectangle.
        /// </summary>
        private BoundRect snakeBounds;

        /// <summary>
        /// The bit-map, describes the changed values.
        /// </summary>
        private UInt32 DirtyValues = 0;
        #endregion

        #region initializing
        /// <summary>
        /// Create new network snake.
        /// </summary>
        /// <param name="tcpClient">New accepted connection (probably) requesting for new snake.</param>
        /// <param name="posStart">Starting position of the new snake generated by the World.</param>
        /// <param name="snakeId">Unique snake identifier.</param>
        public Snake(TcpClient tcpClient, Position posStart, UInt32 snakeId)
        {
            // initialize network connection
            networkStream = tcpClient.GetStream();
            networkStream.WriteTimeout = 5000;  // 5,0 sec
            networkStream.ReadTimeout = 20000;  // 20,0 sec
            
            br = new BinaryReader(networkStream);
            bw = new BufferedBinaryWriter(networkStream, new MemoryStream());
                        
            //tcpClient.Client.

            // initialize starting state
            segments = lastSegment = null;
            segmentsLength = 0.0; // no segments
            
            head = new Position(posStart);    //
            snakeHeadDirection = 0.0;

            snakeBounds = new BoundRect(head, head);
            
            // init ID
            this.snakeId = snakeId;
        }

        #endregion

        #region Logged snakes

        /// <summary>
        /// info about the logged snake
        /// </summary>
        private UserInfo _loggedWebUser = null;

        protected DateTime playStartTime = DateTime.Now;
        protected int suicidesCount = 0;
        protected int killsCount = 0;

        /// <summary>
        /// generate hash (to be send via emails and other unsafe paths)
        /// </summary>
        /// <param name="text"></param>
        /// <returns></returns>
        private static string GenerateHash(string text)
        {
            byte[] bdata = Encoding.UTF8.GetBytes(text);
            byte[] bhash = new SHA256Managed().ComputeHash(bdata);
            return Convert.ToBase64String(bhash);
        }

        /// <summary>
        /// Login the user using email and password.
        /// </summary>
        /// <param name="userEmail"></param>
        /// <param name="passwordHash"></param>
        public void Login(string userEmail, string password)
        {
            // login, can throw an exception
            var webDb = new webDataContext();
            _loggedWebUser = webDb.UserInfos.Single(u => u.email == userEmail.ToLower());
            if (GenerateHash(password + _loggedWebUser.saltHash) != _loggedWebUser.passwordHash)
                throw new Exception("Invalid password");

            this.Name = "® " + _loggedWebUser.name;  // registered user name
            
            // start values
            playStartTime = DateTime.Now;
        }

        private static object _lockDbSubmit = new object();

        /// <summary>
        /// Users session end.
        /// </summary>
        public void Logout()
        {
            try
            {
                DateTime playDate = DateTime.Now.Date;

                // get and create snake user if not yet
                var snakeDb = new snakeworldDataContext();
                SnakeInfo loggedSnakeUser;

                lock (_lockDbSubmit)
                {
                    if (_loggedWebUser != null)
                        loggedSnakeUser = snakeDb.SnakeInfos.SingleOrDefault(u => u.userId == _loggedWebUser.userId && u.playDate == playDate);
                    else
                        loggedSnakeUser = snakeDb.SnakeInfos.SingleOrDefault(u => u.userId == (-1) && u.playDate == playDate);

                    if (loggedSnakeUser == null)
                    {
                        loggedSnakeUser = new SnakeInfo();

                        if (_loggedWebUser != null) loggedSnakeUser.userId = _loggedWebUser.userId;
                        else loggedSnakeUser.userId = (-1);

                        loggedSnakeUser.playDate = playDate;

                        snakeDb.SnakeInfos.InsertOnSubmit(loggedSnakeUser);
                    }

                    // update statistics
                    loggedSnakeUser.plays++;
                    loggedSnakeUser.kills += killsCount;
                    loggedSnakeUser.suicides += suicidesCount;

                    TimeSpan playLength = DateTime.Now - playStartTime;
                    loggedSnakeUser.timeSecondsPlayed += (int)playLength.TotalSeconds;

                    // update snake high score
                    if (loggedSnakeUser.maxLength < snakeLength)
                        loggedSnakeUser.maxLength = snakeLength;

                    // save changes into the database
                    snakeDb.SubmitChanges();
                }

                _loggedWebUser = null;
            }
            catch(Exception ex)
            {
                try
                {
                    FileInfo f = new FileInfo("snakeworld-log.txt");
                    StreamWriter w = f.AppendText();
                    w.WriteLine(ex.ToString());
                    w.Close();
                }catch(Exception)
                {
                }
            }
        }

        /// <summary>
        /// this snake killed another snake (or himself)
        /// </summary>
        /// <param name="deadSnakeId"></param>
        public void SnakeKilled(uint deadSnakeId)
        {
            if (deadSnakeId == snakeId)
            {   // suicide
                ++suicidesCount;
            }
            else
            {
                // ++
                ++killsCount;
            }
        }

        #endregion

        #region values
        /// <summary>
        /// Add new segment on the beginning.
        /// </summary>
        /// <param name="posSegment">New segment position.</param>
        public void OnNewSegmentReceived(UInt32 segId, Position posSegment)
        {
            rwLock.AcquireWriterLock(-1);

            {
                // update head position
                head = new Position(posSegment);

                // create new snake segment
                SnakeSegment newSegment = new SnakeSegment(posSegment, segId);

                if (lastSegment != null)
                {
                    // update current segments length (sum of distances between segments)
                    segmentsLength += lastSegment.position.Distance(posSegment);

                    // insert newSegment on the list end
                    lastSegment.nextSegment = newSegment;

                }
                else
                {
                    // update current segments length (sum of distances between segments)
                    segmentsLength = 0.0;

                    // insert newSegment on the list end
                    segments = newSegment;
                }

                // set as new last segment
                lastSegment = newSegment;

                RealSpeedCheck();

                // remove old segments
                CutOldSegments();

                // update the snake segments length (recompute, because of floating-point number precision after several operations)
                if ((segId & 0x100) == 0) // do update only once per 256 calls
                {
                    RefreshSegmentsLength();
                }

                // segments are dirty now (the last segment will be send to other clients)
                DirtyValues |= DirtyValueBits.Segment;
            }

            rwLock.ReleaseWriterLock();
        }

        /// <summary>
        /// Update the segments length.
        /// Sum of distances between segments.
        /// </summary>
        private void RefreshSegmentsLength()
        {
            double dNewSegmentsLength = 0.0;

            if (segments != null)
            {
                SnakeSegment    prevSeg = segments,
                                curSeg = segments.nextSegment;

                while (curSeg != null)
                {
                    // add the distance between this two segments
                    dNewSegmentsLength += curSeg.position.Distance(prevSeg.position);

                    // next segment
                    prevSeg = curSeg;
                    curSeg = curSeg.nextSegment;
                }
            }

            // update the segments length value
            segmentsLength = dNewSegmentsLength;
        }

        /// <summary>
        /// Cuts off the segments after snakeLength
        /// segments must be not null.
        /// </summary>
        private void CutOldSegments()
        {
            double headDistance = head.Distance(lastSegment.position);
            
            while (segments.nextSegment != null)    // we have at least two segments
            {
                // compute the distance between last two segments
                double length = segments.position.Distance(segments.nextSegment.position);

                // too old segments (after snakeLength) are cut off
                if ((segmentsLength - length + headDistance) >= snakeLength)
                {
                    segments = segments.nextSegment;    // cut of the tail segment

                    segmentsLength -= length;           // decrease the segmentsLength
                }
                else
                {   // there are no old segments
                    break;
                }   
            }
        }

        /// <summary>
        /// Real speed check failures count.
        /// </summary>
        private int _realSpeedCheckFailCount = 0;

        /// <summary>
        /// Checks the real snake speed.
        /// Throws the InvalidDataException in case of too high snake speed.
        /// </summary>
        private void RealSpeedCheck()
        {
            if (segments != null && lastSegment != null)
            {
                TimeSpan segmentsTimeSpan = lastSegment.timeCreated - segments.timeCreated;

                if (segmentsTimeSpan.TotalSeconds > 2.0)
                {   // at least 2 seconds of active segments

                    double realSpeed = segmentsLength / segmentsTimeSpan.TotalSeconds;

                    if (realSpeed > (snakeSpeed + 2.0))
                    {
                        if ((++_realSpeedCheckFailCount) > 8)
                            throw new InvalidDataException("Real snake speed does not match ...");
                    }
                    else
                    {
                        _realSpeedCheckFailCount = 0;
                    }
                }
            }
        }

        /// <summary>
        /// User name
        /// </summary>
        public string Name
        {
            get
            {
                return _Name;
            }
            set
            {
                _Name = value;
            }
        }

        /// <summary>
        /// User description
        /// </summary>
        public string Description
        {
            get
            {
                return _Description;
            }
            set
            {
                _Description = value;
            }
        }

        /// <summary>
        /// Users snake texture file.
        /// Throws InvalidDataException on wrong value.
        /// </summary>
        public string TextureFile
        {
            get
            {
                return _TextureFile;
            }
            set
            {
                string filename = "public\\media\\snakes\\" + value;
                FileInfo fi = new FileInfo(filename);

                if (!fi.Exists)
                    throw new InvalidDataException("\"" + value + "\" is not a valid texture!");

                _TextureFile = value;
            }
        }

        /// <summary>
        /// Snake body type.
        /// Throws InvalidDataException on wrong value.
        /// </summary>
        public string BodyType
        {
            get
            {
                return _BodyType;
            }
            set
            {
                _BodyType = value;
            }
        }

        /// <summary>
        /// Snake length. (in meters)
        /// </summary>
        public double Length
        {
            set
            {
                snakeLength = value;

                DirtyValues |= DirtyValueBits.Length;
            }
            get
            {
                return snakeLength;
            }
        }

        /// <summary>
        /// Snake speed. (in meters/sec)
        /// </summary>
        public double Speed
        {
            set
            {
                snakeSpeed = value;

                DirtyValues |= DirtyValueBits.Speed;
            }
            get
            {
                return snakeSpeed;
            }
        }

        /// <summary>
        /// Snake head direction. (in radians)
        /// </summary>
        public double HeadDirection
        {
            set
            {
                snakeHeadDirection = value;

                DirtyValues |= DirtyValueBits.HeadDirection;
            }
            get
            {
                return snakeHeadDirection;
            }
        }

        /// <summary>
        /// Returns unique snake identifier chosen by the server in constructor.
        /// </summary>
        public UInt32 Id()
        {
            return snakeId;
        }

        /// <summary>
        /// Returns snake head position;
        /// </summary>
        public Position HeadPosition
        {
            get
            {
                return head;
            }
            set
            {
                head = value;

                DirtyValues |= DirtyValueBits.Head;
            }
        }

        /// <summary>
        /// get/set snake bounding rect
        /// </summary>
        public override BoundRect Bound
        {
            get
            {
                return snakeBounds;
            }
            set
            {
                snakeBounds = value;
            }
        }

        /// <summary>
        /// Mark all values as clean.
        /// </summary>
        public void ClearDirtyValues()
        {
            DirtyValues = DirtyValueBits.Nothing;
        }

        #endregion

        #region sending

        /// <summary>
        /// Sends the unique identifier of the snake.
        /// That identify the following data.
        /// </summary>
        /// <param name="writer">Target client.</param>
        private void SendSnakeId(BinaryWriter bw)
        {
            ConnectionData.Send_CmdId(bw,ECmdIds.CMD_RECEIVING_SNAKE);
            bw.Write((uint)snakeId);
        }

        /// <summary>
        /// Sends the unique identifier of the snake when sending whole snake data.
        /// That identify the following data.
        /// </summary>
        /// <param name="writer">Target client.</param>
        private void SendWholeSnakeId(BinaryWriter bw)
        {
            ConnectionData.Send_CmdId(bw, ECmdIds.CMD_NEWSNAKE);
            bw.Write((uint)snakeId);
            //Debug.WriteLine(snakeId + " whole snake");
        }

        /// <summary>
        /// Sends the unique identifier of the snake when sending clients snake.
        /// That identify the following data.
        /// </summary>
        /// <param name="writer">Target client. ( == this snake )</param>
        private void SendYourSnakeId()
        {
            ConnectionData.Send_CmdId(bw, ECmdIds.CMD_YOURSNAKEID);
            bw.Write((uint)snakeId);
        }

        /// <summary>
        /// Send the specified segment info to the client.
        /// </summary>
        /// <param name="writer">Target client.</param>
        /// <param name="segment">Segment to be sent.</param>
        private void SendSegment(BinaryWriter bw, SnakeSegment segment)
        {
            if (segment != null)
            {
                ConnectionData.Send_CmdId(bw, ECmdIds.CMD_SNAKE_SEG);
                bw.Write((uint)segment.id);
                bw.Write((double)segment.position.x);
                bw.Write((double)segment.position.y);
            }
        }

        /// <summary>
        /// Sends all segments information to the client.
        /// </summary>
        /// <param name="client">Target client.</param>
        private void SendAllSegments(BinaryWriter bw)
        {
            for (SnakeSegment seg = segments; seg != null; seg = seg.nextSegment)
            {
                // send the segment info
                SendSegment(bw, seg);
            }
        }

        /// <summary>
        /// Sends the snake specification to the client.
        /// </summary>
        /// <param name="writer">Target client.</param>
        private void SendSpecification(BinaryWriter bw)
        {
            if (Name != null)
            {
                ConnectionData.Send_CmdId(bw, ECmdIds.CMD_NAME);
                ConnectionData.Send_String(bw, Name);
            }
            if (Description != null)
            {
                ConnectionData.Send_CmdId(bw, ECmdIds.CMD_DESCRIPTION);
                ConnectionData.Send_String(bw, Description);
            }

            if (LanguageCode != 0)
            {
                ConnectionData.Send_CmdId(bw, ECmdIds.CMD_LANGUAGE);
                bw.Write(LanguageCode); // 4 bytes language code
            }

            if (TextureFile != null)
            {
                ConnectionData.Send_CmdId(bw, ECmdIds.CMD_TEXTURE);
                ConnectionData.Send_String(bw, TextureFile);
            }

            if (BodyType != null)
            {
                ConnectionData.Send_CmdId(bw, ECmdIds.CMD_TYPE);
                ConnectionData.Send_String(bw, BodyType);
            }

        }

        /// <summary>
        /// Sends the current snake head position
        /// </summary>
        /// <param name="writer">Target client.</param>
        private void SendHead(BinaryWriter bw)
        {
            ConnectionData.Send_CmdId(bw, ECmdIds.CMD_SNAKE_HEAD);
            bw.Write((double)head.x);
            bw.Write((double)head.y);
        }

        /// <summary>
        /// Sends the head direction
        /// </summary>
        /// <param name="writer"></param>
        private void SendHeadDirection(BinaryWriter bw)
        {
            ConnectionData.Send_CmdId(bw, ECmdIds.CMD_SNAKE_DIR);
            bw.Write((double)snakeHeadDirection);
        }

        /// <summary>
        /// Sends the current snake length
        /// </summary>
        /// <param name="writer">Target client.</param>
        private void SendLength(BinaryWriter bw)
        {
            ConnectionData.Send_CmdId(bw, ECmdIds.CMD_SNAKE_LENGTH);
            bw.Write((double)snakeLength);
        }

        /// <summary>
        /// Sends the current snake speed
        /// </summary>
        /// <param name="writer">Target client.</param>
        private void SendSpeed(BinaryWriter bw)
        {
            ConnectionData.Send_CmdId(bw, ECmdIds.CMD_SNAKE_SPEED);
            bw.Write((double)snakeSpeed);
        }

        /// <summary>
        /// Send all available information about the snake without specifying command block header (SNAKE,WHOLESNAKE,YOURSNAKE)
        /// - Specification (Name, Description, ...)
        /// - Segments
        /// - Head position & direction
        /// - Length, Speed
        /// </summary>
        /// <param name="writer">Target client.</param>
        private void SendEverythingWithoutHeader(BinaryWriter bw)
        {
            SendSpecification(bw);

            SendHeadDirection(bw);
            SendHead(bw);
            SendSpeed(bw);
            SendLength(bw);

            SendAllSegments(bw);
        }

        /// <summary>
        /// Sends all available information about this snake.
        /// New thread will be used.
        /// </summary>
        /// <param name="writer">Target client.</param>
        public void SendEverything(BinaryWriter bw)
        {
            ThreadPool.QueueUserWorkItem(_SendEverything, new _SendEverythingParam(bw));
        }

        /// <summary>
        /// Sends all available information to the client that owns this snake
        /// </summary>
        public void SendAsYourSnake()
        {
            rwLock.AcquireReaderLock(-1);// LOCK

            lock (bw)
            {
                try
                {
                    SendYourSnakeId();

                    SendEverythingWithoutHeader(bw);

                    ConnectionData.Send_CmdId(bw, ECmdIds.CMD_BLOCKEND); // block end
                    bw.Flush();
                }
                catch (Exception)
                {
                    try { bw.Close(); }
                    catch (Exception) { }
                }
            }

            rwLock.ReleaseReaderLock();
        }

        /// <summary>
        /// Sends modified values to the client.
        /// New thread will be used.
        /// </summary>
        /// <param name="writer">Target client.</param>
        public void SendDirtyValues(Snake targetSnake)
        {
            AddSegmentToSend(targetSnake, lastSegment); // next segment to be send to the targetSnake

            ThreadPool.QueueUserWorkItem(_SendDirtyValues, new _SendDirtyValuesParam(targetSnake, DirtyValues));
        }

        /// <summary>
        /// Sends the information I was killed.
        /// New thread will be used.
        /// </summary>
        /// <param name="writer">Target client.</param>
        /// <param name="killedBySnakeId">ID of snake that killed me.</param>
        public void SendImDead(BinaryWriter bw, UInt32 killedBySnakeId)
        {
            ThreadPool.QueueUserWorkItem(_SendImDead, new _SendImDeadParam(bw,killedBySnakeId));
        }

        /// <summary>
        /// Check for modified values.
        /// </summary>
        /// <returns>Returns true if there are any modified values, otherwise false.</returns>
        public bool HasDirtyValues()
        {
            return (DirtyValues & DirtyValueBits.Segment) != 0; // only if segment is added, clients should be informed ... otherwise they could get too old info
        }

        #region SendEverything on the own thread

        private class _SendEverythingParam
        {
            public readonly BinaryWriter bw;
            public _SendEverythingParam(BinaryWriter bw)
            {
                this.bw = bw;
            }
        }
        private void _SendEverything(object obj)
        {
            var p = (_SendEverythingParam)obj;
            
            rwLock.AcquireReaderLock(-1);// LOCK

            lock (p.bw)
            {
                try
                {   // writer should be disconnected
                    SendWholeSnakeId(p.bw);

                    SendEverythingWithoutHeader(p.bw);

                    ConnectionData.Send_CmdId(p.bw, ECmdIds.CMD_BLOCKEND); // block end
                    p.bw.Flush();
                }
                catch (Exception)
                {
                    try { p.bw.Close(); }
                    catch (Exception) { }
                }
            }

            rwLock.ReleaseReaderLock();
        }

        #endregion

        #region SendDirtyValues on the own thread

        #region Segments to send

        private Dictionary<Snake, List<SnakeSegment>> SegmentsToSend = new Dictionary<Snake, List<SnakeSegment>>(); // TODO: possible memory leak, snake dies and there are segment in this buffer

        private void AddSegmentToSend(Snake targetSnake, SnakeSegment segment)
        {
            lock (SegmentsToSend)
            {
                List<SnakeSegment> segments;
                if (!SegmentsToSend.TryGetValue(targetSnake, out segments))
                {
                    SegmentsToSend[targetSnake] = segments = new List<SnakeSegment>();
                }

                segments.Add(segment);
            }
        }
        private SnakeSegment PopNextSegmentToSend(Snake targetSnake)
        {
            lock (SegmentsToSend)
            {
                List<SnakeSegment> segments;
                if (SegmentsToSend.TryGetValue(targetSnake, out segments))
                {
                    if (segments.Count > 0)
                    {
                        SnakeSegment firstSegmentInTheList = segments[0];
                        segments.RemoveAt(0);

                        if (segments.Count == 0)
                        {
                            SegmentsToSend.Remove(targetSnake);
                        }

                        return firstSegmentInTheList;
                    }
                }
            }

            return null;
        }

        #endregion

        private class _SendDirtyValuesParam
        {
            public readonly Snake targetSnake;
            public readonly uint DirtyValues;
            
            public _SendDirtyValuesParam(Snake targetSnake, uint DirtyValues)
            {
                this.targetSnake = targetSnake;
                this.DirtyValues = DirtyValues;
            }
        }
        private void _SendDirtyValues(object obj)
        {
            var p = (_SendDirtyValuesParam)obj;

            BinaryWriter bw = p.targetSnake.bw;

            if (p.DirtyValues == DirtyValueBits.Everything)
            {   // new snake
                _SendEverything(new _SendEverythingParam(bw));
            }
            else if (p.DirtyValues != DirtyValueBits.Nothing)
            {   // just modified snake


                //rwLock.AcquireReaderLock(-1);// LOCK

                lock (bw)
                {
                    try
                    {   // writer should be disconnected
                        SendSnakeId(bw);

                        if ((p.DirtyValues & DirtyValueBits.HeadDirection) != 0)
                        {   //
                            SendHeadDirection(bw);
                        }

                        if ((p.DirtyValues & DirtyValueBits.Head) != 0)
                        {   //
                            SendHead(bw);
                        }

                        if ((p.DirtyValues & DirtyValueBits.Speed) != 0)
                        {
                            SendSpeed(bw);
                        }

                        if ((p.DirtyValues & DirtyValueBits.Length) != 0)
                        {
                            SendLength(bw);
                        }

                        SnakeSegment segment;

                        while ((segment = PopNextSegmentToSend(p.targetSnake)) != null)
                        {
                            // send the last segment only
                            SendSegment(bw, segment);   // includes head
                        }

                        bw.Flush();
                    }
                    catch (Exception)
                    {
                        try { bw.Close(); }
                        catch (Exception) { }
                    }
                }

                //rwLock.ReleaseReaderLock();
            }
        }

        #endregion

        #region SendImDead on the own thread

        private class _SendImDeadParam
        {
            public readonly BinaryWriter bw;
            public readonly UInt32 killedBySnakeId;
            public _SendImDeadParam(BinaryWriter bw, UInt32 killedBySnakeId)
            {
                this.bw = bw;
                this.killedBySnakeId = killedBySnakeId;
            }
        }
        private void _SendImDead(object obj)
        {
            var p = (_SendImDeadParam)obj;

            lock (p.bw)
            {
                try
                {
                    SendSnakeId(p.bw);

                    ConnectionData.Send_CmdId(p.bw, ECmdIds.CMD_SNAKE_DEAD);
                    p.bw.Write((UInt32)p.killedBySnakeId);

                    p.bw.Flush();
                }
                catch (Exception)
                {
                    try { p.bw.Close(); }
                    catch (Exception) { }
                }
            }
        }

        #endregion

        #endregion

    }
}
